# Overmind GUI Decoupling Architecture

## Current Architecture (TIGHTLY COUPLED)

### Problem Statement
The current Overmind GUI system is tightly coupled where the GUI server process directly owns and manages the overmind process. This creates several limitations:

1. **Restart Dependency**: GUI restart requires overmind restart
2. **No Reconnection**: Can't connect to existing overmind instances
3. **Data Loss**: Output is lost when GUI restarts (10k message memory buffer)
4. **Single Point of Failure**: Both GUI and overmind die together

### Current Data Flow
```
┌─────────────────────────────────────────────────────────────┐
│                    GUI SERVER PROCESS                       │
│  ┌─────────────────┐    ┌──────────────┐    ┌─────────────┐ │
│  │ OvermindCtrl    │───→│ UpdateQueue  │───→│ API Routes  │ │
│  │ (owns subprocess)│    │ (memory)     │    │             │ │
│  └─────────────────┘    └──────────────┘    └─────────────┘ │
│           │                                                  │
│           ↓                                                  │
│  ┌─────────────────┐                                        │
│  │ Overmind Process│                                        │
│  │ (child process) │                                        │
│  └─────────────────┘                                        │
└─────────────────────────────────────────────────────────────┘
                                │
                                ↓
                    ┌─────────────────────┐
                    │    Frontend         │
                    │    (polling)        │
                    └─────────────────────┘
```

### Current Coupling Points
1. **Process Ownership**: GUI server spawns overmind as subprocess
2. **Lifecycle Management**: GUI shutdown kills overmind
3. **Memory Storage**: UpdateQueue stores output only in RAM
4. **Direct Communication**: OvermindController talks directly to overmind subprocess

---

## New Architecture (DECOUPLED)

### Design Goals
1. **Independent Lifecycle**: Overmind and GUI can start/stop independently
2. **Reconnection**: GUI can connect to existing overmind instances
3. **Persistence**: Output history survives GUI restarts
4. **Multiple Clients**: Multiple GUI instances can connect to same overmind

### Solution Approaches (Best → Worst Case)

## SOLUTION 1: OVERMIND DAEMON + PERSISTENT STORAGE (BEST CASE)

### Architecture Overview
Create a standalone overmind daemon process that:
- Runs overmind independently of GUI
- Stores output persistently (SQLite or file-based)
- Provides API/socket interface for GUI connections
- Supports multiple GUI clients

### Components

#### A. Overmind Daemon Process (`overmind_daemon.py`)
```
┌─────────────────────────────────────────────────────────────┐
│                    OVERMIND DAEMON                          │
│  ┌─────────────────┐    ┌──────────────┐    ┌─────────────┐ │
│  │ OvermindManager │───→│ OutputStore  │    │ DaemonAPI   │ │
│  │ (owns subprocess)│    │ (persistent) │───→│ (HTTP/WS)   │ │
│  └─────────────────┘    └──────────────┘    └─────────────┘ │
│           │                      │                          │
│           ↓                      ↓                          │
│  ┌─────────────────┐    ┌──────────────┐                   │
│  │ Overmind Process│    │   SQLite     │                   │
│  │ (child process) │    │   Database   │                   │
│  └─────────────────┘    └──────────────┘                   │
└─────────────────────────────────────────────────────────────┘
```

**Key Features:**
- Standalone process independent of GUI
- Persistent storage of all output and state
- REST API + WebSocket for real-time updates
- Process discovery and connection management
- Multiple client support

#### B. GUI Client (`gui_client.py`)
```
┌─────────────────────────────────────────────────────────────┐
│                     GUI CLIENT                             │
│  ┌─────────────────┐    ┌──────────────┐    ┌─────────────┐ │
│  │ DaemonClient    │───→│ LocalCache   │───→│ API Routes  │ │
│  │ (HTTP + WS)     │    │ (optional)   │    │             │ │
│  └─────────────────┘    └──────────────┘    └─────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                ↓
                    ┌─────────────────────┐
                    │    Frontend         │
                    │    (polling)        │
                    └─────────────────────┘
```

**Key Features:**
- Connects to daemon via HTTP/WebSocket
- Can reconnect after restarts
- Optional local caching for performance
- Discovers available overmind instances

### Data Storage Schema (SQLite)
```sql
-- Output lines with full history
CREATE TABLE output_lines (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp REAL NOT NULL,
    process_name TEXT NOT NULL,
    raw_text TEXT NOT NULL,
    html_content TEXT NOT NULL,
    clean_text TEXT NOT NULL,
    message_id INTEGER NOT NULL
);

-- Process states and metadata
CREATE TABLE processes (
    name TEXT PRIMARY KEY,
    status TEXT NOT NULL,
    selected BOOLEAN DEFAULT TRUE,
    last_updated REAL NOT NULL
);

-- System events and metadata
CREATE TABLE events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp REAL NOT NULL,
    event_type TEXT NOT NULL,
    data TEXT NOT NULL
);
```

### Communication Protocol
```javascript
// WebSocket Messages
{
    "type": "output_batch",
    "lines": [
        {
            "id": 12345,
            "timestamp": 1635123456.789,
            "process": "web",
            "html": "<span style='color: green'>Started</span>",
            "text": "Started"
        }
    ]
}

{
    "type": "status_update",
    "updates": {
        "web": "running",
        "worker": "stopped"
    }
}

// HTTP API Endpoints
GET /api/instances          # List available overmind instances
POST /api/connect           # Connect to specific instance
GET /api/output             # Get output with pagination/filters
POST /api/process/start     # Process control
```

---

## SOLUTION 2: UNIX SOCKET BRIDGE (MEDIUM CASE)

### Architecture Overview
Create a lightweight bridge process that connects to overmind's existing Unix socket and provides HTTP API.

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Overmind      │───→│ Socket Bridge   │───→│   GUI Client    │
│   (standalone)  │    │ (HTTP server)   │    │   (simplified)  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        │                       │                       │
   Unix Socket              HTTP API                Frontend
  .overmind.sock         REST + Polling            (existing)
```

**Benefits:**
- Uses existing overmind socket interface
- Minimal changes to current GUI code
- Overmind runs independently
- Simple bridge process

**Limitations:**
- Limited by overmind's native capabilities
- May not have full output history
- Bridge becomes new single point of failure

---

## SOLUTION 3: PROCESS MONITORING (WORST CASE)

### Architecture Overview
GUI detects and connects to already-running overmind processes without daemon.

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Overmind      │    │ Process Monitor │───→│   GUI Client    │
│   (external)    │───→│ (attach to PID) │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

**Benefits:**
- Works with any existing overmind instance
- No additional daemon process needed

**Limitations:**
- Complex process attachment
- No output history before attachment
- Platform-specific implementation
- Limited control capabilities

---

## IMPLEMENTATION STRATEGY

### Phase 1: Preparation
1. Create daemon process structure
2. Implement persistent storage layer
3. Design API protocol
4. Build basic daemon-GUI communication

### Phase 2: Migration
1. Extract overmind management from GUI server
2. Implement daemon API endpoints
3. Modify GUI to use daemon client
4. Add connection management and discovery

### Phase 3: Enhancement
1. Add persistent output storage
2. Implement WebSocket real-time updates
3. Add multi-client support
4. Create process management improvements

### Rollback Plan
- Keep current architecture as fallback mode
- Add `--legacy` flag to run in coupled mode
- Gradual migration with feature flags
- Comprehensive testing at each phase

---

## TECHNICAL DECISIONS

### Storage Technology: SQLite
- **Pros**: Lightweight, serverless, ACID compliant, excellent Python support
- **Cons**: Single writer limitation (acceptable for daemon architecture)
- **Alternative**: File-based circular buffers for output only

### Communication Protocol: HTTP + WebSocket
- **HTTP**: REST API for configuration, discovery, and batch operations
- **WebSocket**: Real-time output streaming and status updates
- **Alternative**: Pure HTTP polling (current system compatibility)

### Process Management: Systemd Integration
- Create systemd service for daemon
- Auto-restart capabilities
- Proper logging and monitoring
- User session vs system-wide deployment options

### Discovery Mechanism: File-based
- Daemon writes status to `~/.overmind-gui/instances.json`
- GUI scans for available instances
- Include PID, socket path, API port
- Alternative: Network discovery protocols

---

## MIGRATION CONSIDERATIONS

### Backward Compatibility
- Support both legacy and new modes during transition
- Maintain existing API contracts initially
- Gradual deprecation of coupled features

### Data Migration
- Export existing process configurations
- Preserve user preferences and settings
- Handle output buffer transition gracefully

### Error Handling
- Robust reconnection logic for GUI client
- Daemon crash recovery procedures
- Network interruption handling
- Fallback to legacy mode on failure

### Performance Impact
- Additional network hop between GUI and overmind
- Persistent storage overhead
- Memory usage optimization for large output buffers
- Connection pooling and caching strategies

---

## TESTING STRATEGY

### Unit Tests
- Daemon process management
- Storage layer operations
- API endpoint functionality
- GUI client connection logic

### Integration Tests
- Full daemon + GUI workflow
- Process restart scenarios
- Network failure recovery
- Multi-client scenarios

### Performance Tests
- Large output volume handling
- Long-running stability
- Memory usage profiling
- Connection scalability

### User Acceptance Tests
- GUI restart without overmind impact
- Reconnection after network issues
- Multiple GUI instances
- Output history preservation

---

## SUCCESS CRITERIA

1. ✅ GUI can restart without affecting overmind
2. ✅ GUI can connect to existing overmind instances
3. ✅ Output history survives GUI restarts
4. ✅ Performance matches or exceeds current system
5. ✅ Zero data loss during normal operations
6. ✅ Clear migration path from current architecture
7. ✅ Maintains all existing functionality

---

## IMPLEMENTATION PRIORITY

**MUST HAVE (Phase 1):**
- Daemon process with overmind management
- Basic persistent storage
- GUI client connection
- Process control API

**SHOULD HAVE (Phase 2):**
- WebSocket real-time updates
- Complete output history storage
- Multi-instance discovery
- Robust error handling

**COULD HAVE (Phase 3):**
- Multi-client support
- Advanced filtering/search in daemon
- Performance optimizations
- Monitoring and metrics

This architecture enables the core requirement: **restarting the GUI without restarting overmind**, while providing a robust foundation for enhanced capabilities.