#!/usr/bin/env python3
"""
Overmind GUI Web Application Runner

This script provides access to all application functionality including:
- Running the backend (which manages daemon connection)
- Controlling the daemon (process start/stop/restart)
- Running tests
- Development commands

Usage:
    ./run [command] [options]

Commands:
    server          Start the backend server (default - looks for Procfile in current dir)
    server <path>   Start the backend server from a specific directory (looks for Procfile there)
    test_proc       Run backend with demo Procfile for testing (copies to output/test-run)

    Daemon Control:
    ps [path]       Show process status for daemon in current dir or specified path
    status [path]   Show daemon status
    start <proc>    Start a specific process
    stop <proc>     Stop a specific process
    restart <proc>  Restart a specific process
    quit [path]     Stop daemon and all processes

    Development:
    test           Run all tests
    test <module>  Run tests for specific module
    lint           Run linting
    setup          Install dependencies and setup
    dev            Start development backend with debug
    help           Show this help message

Examples:
    ./run                           # Start backend, use current dir's Procfile
    ./run server                    # Start backend, use current dir's Procfile
    ./run server /path/to/real/app  # Start backend, use Procfile in /path/to/real/app
    ./run test_proc                 # Run backend with demo Procfile (logs go to output/)

    ./run ps                        # Show process status (uses current directory)
    ./run ps output/test-run        # Show process status for test-run
    ./run restart web               # Restart the 'web' process
    ./run stop api                  # Stop the 'api' process
    ./run quit                      # Stop daemon and all processes
    ./run integration               # Run full integration test with browser automation
    ./run test                      # Run all tests
    ./run test utils                # Run tests for utils module
    ./run lint                      # Run linting
    ./run setup                     # Install dependencies
    ./run dev                       # Start with debug mode
"""

import sys
import os
import subprocess
import argparse
from pathlib import Path

# Add current directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

def setup_dependencies():
    """Install Python dependencies"""
    print("Setting up dependencies...")
    try:
        subprocess.run([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"],
                      check=True)
        print("✓ Dependencies installed successfully")
    except subprocess.CalledProcessError as e:
        print(f"✗ Failed to install dependencies: {e}")
        sys.exit(1)

def run_server(debug=False, server_path=None):
    """Start the backend server"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    main_py_path = os.path.join(script_dir, "src", "main.py")

    if server_path:
        print(f"Starting Overmind GUI Backend from {server_path}...")
        if not os.path.isdir(server_path):
            print(f"✗ Directory not found: {server_path}")
            sys.exit(1)

        # Check for Procfile in the target directory
        procfile_path = os.path.join(server_path, "Procfile")
        if not os.path.exists(procfile_path):
            print(f"✗ Procfile not found in {server_path}")
            sys.exit(1)

        working_dir = server_path
    else:
        print("Starting Overmind GUI Backend from current directory...")
        if not os.path.exists("Procfile"):
            print("✗ Procfile not found in current directory")
            sys.exit(1)

        working_dir = os.getcwd()

    # Always use main.py from src/
    if not os.path.exists(main_py_path):
        print(f"✗ main.py not found at {main_py_path}")
        sys.exit(1)

    try:
        env = os.environ.copy()
        if debug:
            env['DEBUG'] = '1'
            print("Debug mode enabled")

        print(f"Working directory: {working_dir}")
        print(f"Running: {main_py_path}")
        subprocess.run([sys.executable, main_py_path], env=env, cwd=working_dir, check=True)
    except subprocess.CalledProcessError as e:
        print(f"✗ Backend failed to start: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n✓ Backend stopped")

def run_tests(module=None):
    """Run tests"""
    if module:
        run_specific_test(module)
    else:
        run_all_tests()

def run_all_tests():
    """Run all JavaScript tests"""
    print("Running all tests...")

    src_dir = Path("src")
    test_files = list(src_dir.glob("*_test.js"))

    if not test_files:
        print("No test files found in src/")
        return

    total_tests = len(test_files)
    passed_tests = 0
    failed_tests = 0

    for test_file in sorted(test_files):
        print(f"\n--- Running {test_file.name} ---")
        try:
            # Run test using Node.js (if available)
            if os.system("command -v node > /dev/null 2>&1") == 0:
                result = subprocess.run(
                    ["node", "--experimental-modules", str(test_file)],
                    capture_output=True,
                    text=True,
                    cwd=src_dir.parent
                )

                if result.returncode == 0:
                    print(result.stdout)
                    passed_tests += 1
                else:
                    print(f"✗ {test_file.name} failed:")
                    print(result.stderr)
                    failed_tests += 1
            else:
                print(f"⚠ Skipping {test_file.name} (Node.js not available)")

        except Exception as e:
            print(f"✗ Error running {test_file.name}: {e}")
            failed_tests += 1

    print(f"\n--- Test Summary ---")
    print(f"Total tests: {total_tests}")
    print(f"Passed: {passed_tests}")
    print(f"Failed: {failed_tests}")

    if failed_tests > 0:
        sys.exit(1)

def run_specific_test(module_name):
    """Run tests for a specific module"""
    print(f"Running tests for {module_name}...")

    test_file = Path(f"src/{module_name}_test.js")

    if not test_file.exists():
        print(f"✗ Test file not found: {test_file}")
        sys.exit(1)

    try:
        if os.system("command -v node > /dev/null 2>&1") == 0:
            result = subprocess.run(
                ["node", "--experimental-modules", str(test_file)],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                print(result.stdout)
                print(f"✓ {module_name} tests passed")
            else:
                print(f"✗ {module_name} tests failed:")
                print(result.stderr)
                sys.exit(1)
        else:
            print("⚠ Node.js not available, cannot run JavaScript tests")

    except Exception as e:
        print(f"✗ Error running {module_name} tests: {e}")
        sys.exit(1)

def run_test_proc(debug=False):
    """Run server with demo Procfile for testing"""
    print("Setting up test run with demo Procfile...")

    script_dir = os.path.dirname(os.path.abspath(__file__))
    demo_procfile = os.path.join(script_dir, "src", "demo.Procfile")

    if not os.path.exists(demo_procfile):
        print(f"✗ Demo Procfile not found at {demo_procfile}")
        sys.exit(1)

    # Create test run directory
    output_dir = os.path.join(script_dir, "output", "test-run")
    os.makedirs(output_dir, exist_ok=True)

    # Copy demo Procfile to test directory
    test_procfile = os.path.join(output_dir, "Procfile")

    try:
        import shutil
        shutil.copy2(demo_procfile, test_procfile)
        print(f"✓ Copied demo Procfile to {test_procfile}")
    except Exception as e:
        print(f"✗ Failed to copy Procfile: {e}")
        sys.exit(1)

    print(f"✓ Test run directory: {output_dir}")
    print(f"✓ Logs and outputs will be saved in {output_dir}")
    print("✓ Starting server...")

    # Run server from the test directory
    run_server(debug=debug, server_path=output_dir)

def run_integration_test():
    """Run the full integration test"""
    print("Running integration test...")

    script_dir = os.path.dirname(os.path.abspath(__file__))
    integration_test_path = os.path.join(script_dir, "src", "integration_test.py")

    if not os.path.exists(integration_test_path):
        print(f"✗ Integration test not found at {integration_test_path}")
        sys.exit(1)

    try:
        result = subprocess.run([sys.executable, integration_test_path], check=True)
        print("✓ Integration test passed")
    except subprocess.CalledProcessError as e:
        print(f"✗ Integration test failed: {e}")
        sys.exit(1)

def run_lint():
    """Run linting on Python files"""
    print("Running linting...")

    python_files = []
    for ext in ['*.py']:
        python_files.extend(Path('.').glob(ext))

    if not python_files:
        print("No Python files found to lint")
        return

    # Try flake8 first, then pylint
    linters = ['flake8', 'pylint']

    for linter in linters:
        if os.system(f"command -v {linter} > /dev/null 2>&1") == 0:
            print(f"Running {linter}...")
            try:
                subprocess.run([linter] + [str(f) for f in python_files], check=True)
                print(f"✓ {linter} passed")
                break
            except subprocess.CalledProcessError as e:
                print(f"✗ {linter} failed: {e}")
                sys.exit(1)
    else:
        print("⚠ No linters (flake8, pylint) available")

def show_help():
    """Show help message"""
    print(__doc__)

def run_daemon_command(command, process_name=None, server_path=None):
    """Run a daemon control command (ps, start, stop, restart, quit, status)"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    native_ctl_path = os.path.join(script_dir, "src", "native_ctl.py")

    # Build command
    cmd = [sys.executable, native_ctl_path]

    # Add working directory if specified
    if server_path:
        cmd.extend(["--working-dir", server_path])

    # Add command
    cmd.append(command)

    # Add process name if specified
    if process_name:
        cmd.append(process_name)

    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        print(f"✗ Command failed: {e}")
        sys.exit(1)

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Overmind GUI Web Application Runner')
    parser.add_argument('command', nargs='?', default='server',
                       help='Command to run (server, test, lint, setup, dev, help)')
    parser.add_argument('path_or_module', nargs='?',
                       help='Path (for server command) or module name (for test command)')

    args = parser.parse_args()

    # Daemon control commands
    if args.command in ['ps', 'status', 'quit']:
        run_daemon_command(args.command, server_path=args.path_or_module)
    elif args.command in ['start', 'stop', 'restart']:
        if not args.path_or_module:
            print(f"Error: {args.command} requires a process name")
            print(f"Usage: ./run {args.command} <process_name>")
            sys.exit(1)
        run_daemon_command(args.command, process_name=args.path_or_module)
    # Regular commands
    elif args.command == 'server':
        run_server(server_path=args.path_or_module)
    elif args.command == 'test_proc':
        run_test_proc(debug=False)
    elif args.command == 'integration':
        run_integration_test()
    elif args.command == 'test':
        run_tests(args.path_or_module)
    elif args.command == 'lint':
        run_lint()
    elif args.command == 'setup':
        setup_dependencies()
    elif args.command == 'dev':
        run_server(debug=True, server_path=args.path_or_module)
    elif args.command == 'help':
        show_help()
    else:
        # Check if the "command" is actually a path (for backwards compatibility)
        if os.path.isdir(args.command):
            print(f"Detected path as command, starting server from: {args.command}")
            run_server(server_path=args.command)
        else:
            print(f"Unknown command: {args.command}")
            show_help()
            sys.exit(1)

if __name__ == '__main__':
    main()